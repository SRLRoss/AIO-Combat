program AIOFighter;
{$include_once ogLib/lib/core/core.Simba}


const

  REVISION = 2.0;

  {                   *Client Settings*
            The size you want your client to be.
  }

  CLIENT_WIDTH = 1280;
  CLIENT_HEIGHT = 720;


  {                  *Setup Tools*
     GATHER_MONSTER_IDs finds IDs that move, then hovers
          over to check for 'Attack' uptext.
    GET_INVENTORY_IDs writelns the all of the Texture IDs
                  in your inventory.
  }

  GATHER_MONSTER_IDs =  false;
  GET_INVENTORY_IDs = false;

  {                   *Thresholds*
        Type in the skills that you will use, in order
                      of priority.
  }

  USE_THRESHOLDS = true;
  THRESHOLD_ORDER = ['forcefulbackhand'];

  {                  *Regeneration*
            Requires Revolution combat mode.
             Health % is randomized by +/-5
  }

  USE_REGENERATE = true;
  REGENERATE_AT = 60;


  {              *Looting Charms and Items*
                   Charm IDs are included.
   Getting the IDs for loot is on the user. I recommend
                  Clarity's Highlight tool.
   Make sure you are using "Custom Looting" in gameplay
                          settings.
  }

  LOOT_CHARMS = true;
  LOOT_ITEMS = false;


  {                   *Looting Bones*
              http://cherrytree.at/misc/vk.htm
   Use the value in the middle column corresponding
                    to actionbar key.
            '1' is 49  (1 KEY); Use 0-9 Keys
  }

  LOOT_BONES = false;
  VKEY_TO_BURY_BONES = 57;


 {                    *Skills to Track*
                          Choose one.
  'attack', 'strength', 'defense', 'ranged', 'mage', or 'overall'
 }

  SKILL_TO_TRACK = 'overall';


 {                          *Food*
    Supports lobster, swordfish, monkfish, shark, rocktail
                 Health % is randomized by +/-5
 }

  USE_FOOD = true;
  EAT_AT_PERCENT = 20;


 {                 *Terminate Failsafes*
              TERMINATE_AFTER calls for minutes.
                  Randomizes +/-5 minutes
 }

  TERMINATE_AT_PERCENT = 10;
  TERMINATE_ON_INVENTORY_FULL = true;
  TERMINATE_AFTER = 300;
  TERMINATE_AT_KILL_COUNT = 999999999;


 {                    *High Alching*
                No need for V_KEY like bones.
 }

 HIGH_ALCH = false;
 HIGH_ALCH_KEY = '-';


 {                  *Potions to drink*
    Supports: Super Attack, Super Strength, Super Defense
   Super Magic, Super Ranging, Prayer Potion, Prayer Renewal
 }

 DRINK_POTIONS = false;
 POTIONS_TO_DRINK = ['Super Attack', 'Super Strength'];


 {                   *Micro Breaking*
       Each break lasts between 10 and 30 seconds
        TAKE_MICRO_BREAK_EVERY calls for minutes.
                   Randomizes +/-5 minutes
 }

  TAKE_MICRO_BREAKS = true;
  TAKE_MICRO_BREAK_EVERY = 10;



var

  {                        *IDs*
              Insert IDs into the arrays below.
  }

  MONSTER_IDs: TCardinalArray := [4089777222, 3070265206, 1696077566, 3151547142];
  LOOT_MODEL_ARRAY: TCardinalArray := [818598493, 1472615824, 3329255693];
  ITEMS_TO_ALCH: TIntegerArray := [75735, 81090, 32130];





(*              Don't edit anything after this.               *)














































  lastFight, center: TPoint;
  currentStatus: string;
  startXP, currentXP, kills, breaksTaken: integer;
  xpBox: TBox;
  xpIcon: glTextureArray;
  microBreakCountdown, terminateTimer: tCountDown;

procedure getUpdate();
var
  newFile: Integer;
  newRev: Extended;
begin
  newRev := strToFloat(getPage('http://tomstewart.net/proxy.php?url=https://raw.githubusercontent.com/SRLRoss/AIO-Combat/master/version.txt'));

  if newRev > REVISION then
  begin
    writeln('Updating from revision ' + REVISION + ' to revision ' + newRev);
    newFile := rewriteFile(scriptPath + 'Ross'' AIO Combat v' + newRev, false);
    writeFileString(newFile, getPage('http://tomstewart.net/proxy.php?url=https://raw.githubusercontent.com/SRLRoss/AIO-Combat/master/Ross''%20AIO%20Combat.simba));
    closeFile(newFile);
    writeln('Please open the new file.');
    terminateScript();
  end
  else
    writeln('Script is up-to-date.');
end;

function tmouse.getTooltip(): string;
override;
var
  funcID: int32;
  funcBounds: tBox;
  funcPointer: pointer;
  funcPointerIndex, funcPointerSize: uInt32 = 0;
begin
  funcPointer := glTextures(funcPointerSize) + (36 * (funcPointerSize - 1));
  if funcPointer <> nil then
  begin
    for funcPointerIndex to funcPointerSize div 5 do
    begin
      if funcPointer ^ = 15878 then
      begin
        funcBounds := [(funcPointer - 88) ^, (funcPointer - 84) ^, (funcPointer + 28) ^, (funcPointer + 32) ^];
        break;
      end;
      funcPointer := funcPointer - 36;
    end;
    if funcPointerIndex < funcPointerSize div 5 then
    begin
      funcPointer := glFonts(funcPointerSize) + (48 * (funcPointerSize - 1));
      if funcPointer <> nil then
      begin
        for funcPointerIndex := 0 to funcPointerSize div 2 do
        begin
          if pointInBox([(funcPointer + 8) ^, (funcPointer + 12) ^], funcBounds) then
          begin
            if (result <> '') and (single((funcPointer + 68) ^) - (single((funcPointer + 20) ^) + integer((funcPointer + 40) ^)) <> 1) then
              result := ' ' + result;
            result := char((funcPointer + 16) ^) + result;
          end
          else if result <> '' then
            break;
          funcPointer := funcPointer - 96;
        end;
      end;
    end;
  end;
  exit(result);
end;

function getTime(time: uint32): string;
var
  h, m, s: integer;
begin
  s := time mod 3600000 mod 60000 div 1000;
  m := time mod 3600000 div 60000;
  h := time div 3600000;
  result:= (toStr(h) + ' h ' + toStr(m) + ' m ' + toStr(s) + ' s');
end;

function getXp(): integer;
begin
  xpBox:=intToBox(xpIcon[low(xpIcon)].bounds.x1 - 150, xpIcon[low(xpIcon)].bounds.y1, xpIcon[low(xpIcon)].bounds.x2, xpIcon[low(xpIcon)].bounds.y2);
  result := explode('+', ogl.getChars(xpBox).toString())[0].parseInt();
end;

procedure progressReport();
var
  currentXp: uint32;
  paintXp, xpHour, killsHour :integer;
  time: string;
begin
  currentXp := getXP();
  paintXp := currentXp - startXp;
  xpHour := round(paintXp * (3600.0 / (getTimeRunning / 1000.0)));
  killsHour :=  round(kills * (3600.0 / (getTimeRunning / 1000.0)));
  time:=getTime(getTimeRunning());
  smart.__graphics.clear;
  smart.__graphics.DrawText(toStr(paintXp) + ' ' + SKILL_TO_TRACK + ' xp gained', 'smallChars', point(11, 11), 1);
  smart.__graphics.DrawText(toStr(paintXp) + ' ' + SKILL_TO_TRACK + ' xp gained', 'smallChars', point(10, 10), clWhite);
  smart.__graphics.DrawText(toStr(xpHour) + ' ' + SKILL_TO_TRACK + ' xp/hr', 'smallChars', point(11, 29), 1);
  smart.__graphics.DrawText(toStr(xpHour) + ' ' + SKILL_TO_TRACK + ' xp/hr', 'smallChars', point(10, 28), clWhite);
  smart.__graphics.DrawText('Kills: ' + toStr(kills), 'smallChars', point(11, 47), 1);
  smart.__graphics.DrawText('Kills: ' + toStr(kills), 'smallChars', point(10, 46), clWhite);
  smart.__graphics.DrawText('Kills/hr: ' + toStr(killsHour), 'smallChars', point(11, 65), 1);
  smart.__graphics.DrawText('Kills/hr: ' + toStr(killsHour), 'smallChars', point(10, 64), clWhite);
  smart.__graphics.DrawText('Status: ' + currentStatus, 'smallChars', point(11, 83), 1);
  smart.__graphics.DrawText('Status: ' + currentStatus, 'smallChars', point(10, 82), clWhite);
  smart.__graphics.DrawText('Time Running: ' + time, 'smallChars', point(11, 101), 1);
  smart.__graphics.DrawText('Time Running: ' + time, 'smallChars', point(10, 100), clWhite);
  if TAKE_MICRO_BREAKS then
  begin
    smart.__graphics.DrawText('Time until next micro break: ' + getTime(microBreakCountdown.timeRemaining()), 'smallChars', point(11, 119), 1);
    smart.__graphics.DrawText('Time until next micro break: ' + getTime(microBreakCountdown.timeRemaining()), 'smallChars', point(10, 118), clWhite);
    smart.__graphics.DrawText('Breaks Taken: ' + toStr(breaksTaken), 'smallChars', point(11, 137), 1);
    smart.__graphics.DrawText('Breaks Taken: ' + toStr(breaksTaken), 'smallChars', point(10, 136), clWhite);
  end;
end;

procedure gatherMonsterIDs;
var
  i, j: integer;
  ID, potentialID, potentialID2: glModelArray;
  excludedIDs: TIntegerArray;
begin
  repeat
  ID:=ogl.getModels();
  excludedIDs:=[4390934, 65536, 65538, 0];
  for i:=0 to high(ID) do
  begin
    if (not excludedIDs.contains(ID[i].id)) then
    begin
      potentialID:=ogl.getModels(ID[i]);
      wait(100);
      potentialID2:=ogl.getModels(ID[i]);
      for j:=0 to high(potentialID) do
      begin
        if (potentialID[j].x > 0) then
          if (potentialID[j].x <> potentialID2[j].x) or (potentialID[j].y <> potentialID2[j].y) then
          begin
            mouse.move(potentialID[j].toPoint());
            wait(100);
            if pos('Attack', mouse.getTooltip()) then
            begin
              writeln('ID ' + toStr(potentialID[j].id) + ' may be a monster.');
              break;
            end
            else
              wait(100);
          end;
      end;
    end;
  end;
  until(false);
end;

procedure getInventoryIDs;
var
  i: integer;
begin
  writeln('Following slots start at 1.');
  for i:=0 to 27 do
  begin
    if (inventory.getSlot(i).id <> 0) then
    begin
      writeln('Slot ' + toStr(i + 1) + ' ID is: ' + toStr(inventory.getSlot(i).id));
    end;
  end;
end;

procedure waitFlag;
begin
  wait(250);
  while (not ogl.getTextures(1275).isEmpty()) do
    wait(1000);
end;

function hasAlchables: boolean;
begin
  result := not inventory.getItems(ITEMS_TO_ALCH).isEmpty();
end;


function drinkPotion(potion: string): boolean;
begin
    case potion of
    'superstrength':
        result := inventory.clickItem([79560, 79815, 77520], [3486515, 3354929, 2894379, 2697258]);
    'superattack':
        result := inventory.clickItem([79560, 79815, 77520], [1118520, 1315894, 1447470, 1842217]);
    'superdefence':
        result := inventory.clickItem([79560, 79815, 77520], [3747601, 3550484, 3024919, 2630941]);
    'supermagic':
        result := inventory.clickItem([79560, 79815, 77520], [1254189, 1451053, 1515815, 1909286]);
    'superranging':
        result := inventory.clickItem([79560, 79815, 77520], [1125945, 1322295, 1451823, 1910315]);
    'prayerpotion':
        result := inventory.clickItem([79560, 79815, 77520], [1128490, 1258793, 1453606, 1845541]);
    'prayerrenewal':
        result := inventory.clickItem([79560, 79815, 77520], [2033156, 2099721, 1969935, 2169114]);
  end;
end;

function hasBuff(buff: string): boolean;
begin
    case buff of
    'superstrength':
        result := not ogl.getTextures([35262], [3482653]).isEmpty();
    'superattack':
        result := not ogl.getTextures([23328], [1710097]).isEmpty();
    'superdefence':
        result := not ogl.getTextures([46691], [1647916]).isEmpty();
    'supermagic':
        result := not ogl.getTextures([44496], [1316644]).isEmpty();
    'superranging':
        result := not ogl.getTextures([21062], [1512203]).isEmpty();
    'prayerpotion':
        result := not (actionbar.getPrayerPoints() < randomRange(35, 55));
    'prayerrenewal':
        result := not ogl.getTextures([55080, 44496]).isEmpty();
  end;
end;

procedure checkBuffs;
var
  i: integer;
  potion: string;
begin
  for i:= 0 to high(POTIONS_TO_DRINK) do
  begin
    potion := lowercase(extractFromStr(POTIONS_TO_DRINK[i], letters));
    if (not hasBuff(potion)) then
      if drinkPotion(potion) then
        wait(randomRange(750, 1250))
      else
      begin
        writeln('Out of ' + POTIONS_TO_DRINK[i] + ' potions.');
        terminateScript;
      end;
  end;
end;

function hasLoot: boolean;
begin
  result:= not ogl.getModels(LOOT_MODEL_ARRAY).isEmpty();
end;

function hasBones: boolean;
begin
  result:= not ogl.getModels(TCardinalArray([2406257549, 189892155, 193554437])).isEmpty();
end;

function hasBonesInventory: boolean;
begin
  result := not inventory.getItems([52275, 62985, 84405, 97410]).isEmpty();
end;

function hasCharms: boolean;
begin
  result:= not ogl.getModels(TCardinalArray([1107824708,585563216,2950982353,3759434362,2984528207,544819542])).isEmpty();
end;

procedure alchItems;
begin
  currentStatus:= 'Alching item.';
  progressReport;
  wait(randomRange(500, 750));
  sendKeys(HIGH_ALCH_KEY, random(25, 40), random(80, 110));
  wait(randomRange(750, 1500));
  inventory.clickItem(ITEMS_TO_ALCH);
  wait(randomRange(750, 1500));
end;

function findAndClick(ID: TCardinalArray = []; optionText: TStringArray = []; point: TPoint = []): boolean;
var
  modelID: glModelArray;
  tries: integer;
begin
  waitFlag;
  if ID.isEmpty() then
  begin
    while (tries < 10) do
    begin
      if (not point.isVisible()) then
      begin
        if (point.x < (CLIENT_HEIGHT / 2)) then
          minimap.setDegrees(minimap.getDegrees() + random(20, 30))
        else
          minimap.setDegrees(minimap.getDegrees() - random(10, 40));
        inc(tries);
      end
      else
      begin
        if optionText.isEmpty() then
        begin
          mouse.click(point.randomizePointEllipse(5), 1);
          exit(true);
        end
        else if (mouse.rightClickOption(point.randomizePointEllipse(5), optionText, 500)) then
          exit(true);
        inc(tries);
      end;
    end;
  end;
  if ogl.getModels(ID).isEmpty() then
    exit(false)
  else
  begin
    while (tries < 10) do
    begin
      modelID := ogl.getModels(ID);
      if ogl.getModels(ID).isEmpty() then
        exit(false);
      if (not center.closest(modelID)[0].isVisible()) then
      begin
        if ((modelID)[0].x < (CLIENT_HEIGHT / 2)) then
          minimap.setDegrees(minimap.getDegrees() + random(20, 30))
        else
          minimap.setDegrees(minimap.getDegrees() - random(10, 40));
        inc(tries);
      end
      else
      begin
        if optionText.isEmpty() then
        begin
          mouse.click(center.closest(modelID)[0].randomizePointEllipse(5), 1);
          exit(true);
        end
        else if (mouse.rightClickOption(center.closest(modelID)[0].randomizePointEllipse(20), optionText, 500)) then
          exit(true)
        else
        begin
        if ((modelID)[0].x < (CLIENT_HEIGHT / 2)) then
          minimap.setDegrees(minimap.getDegrees() + random(5, 15))
        else
          minimap.setDegrees(minimap.getDegrees() - random(5, 15));
        wait(randomRange(250, 750));
        inc(tries);
        end;
      end;
    end;
  end;
  exit(false);
end;

function clickExitButton: boolean;
var
  i: integer;
  exitButton, bounds: glTextureArray;
begin
  exitButton := ogl.getTextures(16320);
  bounds := ogl.getTextures(714000);
  if bounds.isEmpty() then
    exit;
  for i:= 0 to high(exitButton) do
    begin
      if pointInBox(exitButton[i].toPoint(), bounds[low(bounds)].bounds) then
      begin
        mouse.click((exitButton)[i]);
        wait(randomRange(750, 1000));
      end;
    end;
end;

function clickLootCustom: boolean;
var
  lootCustom: glTextureArray;
begin
  lootCustom := ogl.getTextures(91275);
  if (not lootCustom.isEmpty()) then
  begin
    mouse.click(lootCustom[0]);
    wait(randomRange(750, 1000));
    clickExitButton();
  end;
end;

function lootItems: boolean;
begin
 currentStatus:= 'Looting items.';
  progressReport;
  result := findAndClick(LOOT_MODEL_ARRAY);
  if result then
  begin
    waitFlag;
    wait(randomRange(1000, 1250));
  end
  else
    wait(randomRange(200, 500));
  while (not ogl.getTextures(714000).isEmpty()) do
  begin
    clickLootCustom;
  end;
end;

function lootBones: boolean;
begin
  currentStatus:= 'Looting bones.';
  progressReport;
  result := findAndClick([2406257549, 189892155, 193554437], ['bones', 'Bones']);
  if result then
  begin
    waitFlag;
    wait(randomRange(1000, 1250));
  end
  else
    wait(randomRange(200, 500));
end;

function lootCharms: boolean;
begin
  currentStatus:= 'Looting charms.';
  progressReport;
  result := findAndClick([1107824708,585563216,2950982353,3759434362,2984528207,544819542], ['charm']);
  if result then
  begin
    waitFlag;
    wait(randomRange(1000, 1250));
  end
  else
    wait(randomRange(200, 500));
end;

function dropBones: boolean;
var
  boneTextures: glTextureArray;
begin
  currentStatus:= 'Dropping bones.';
  progressReport;
  keyDown(VKEY_TO_BURY_BONES);
  while (hasBonesInventory()) do
  begin
    wait(randomRange(500, 1250));
  end;
  keyUp(VKEY_TO_BURY_BONES);
end;

function lowHealth: boolean;
begin
  result := (actionbar.getLifePoints() < (EAT_AT_PERCENT + randomRange(-5, 5)));
end;

function eatFood: boolean;
var
  food: glTextureArray;
begin
  currentStatus:= 'Eating food.';
  progressReport;
  food := ogl.getTextures([94605, 59670, 102255, 112710, 97410], [3217671, 1445400, 2301468, 3352865, 2300952]);
  if (not food.isEmpty()) then
  begin
    mouse.click(food[0].toPoint().randomizePointEllipse(5), 1);
    wait(randomRange(1250, 1500));
    result := true;
  end;
  exit(result);
end;

function inCombat: boolean;
begin
  if actionbar.getState() then
    result := (ogl.getTextures(7750).indexes() > 1)
  else
    result := (ogl.getTextures(7750).indexes() > 0);
end;

function getLastFight(): TPoint;
var
  ringModel: glModelArray;
begin
  ringModel:=ogl.getModels(TCardinalArray([1829014414, 1938370197]));
  if (not ringModel.isEmpty()) then
    result := center.closest(ringModel)[0]
  else if combat.hasTarget() then
    result := combat.getTarget().toPoint()
  else
    result := lastFight;
  exit(result);
end;

function closestValidModel(arrayResult:gLModelArray; comparePoint: TPoint; distance: Integer):TPoint;
var
  i: integer;
begin
  if arrayResult.isEmpty() then
    result := [0, 0];
  for i := 0 to high(arrayResult) do
  begin
    if (center.closest(arrayResult)[i].distanceFrom(comparePoint) > distance) then
    begin
      result:=center.closest(arrayResult)[i];
      exit(result);
    end;
  end;
  result := [0, 0];
end;

function attackMonster: boolean;
var
  currentRadians, adjustment: extended;
  monster: TIntegerArray;
  rx, ry, x, y, tries: integer;
  attackTimer: tCountDown;
  closestMonster: TPoint;
begin
  rx := 0;
  ry := 0;
  tries := 0;
  while (tries < 6) do
  begin
    closestMonster := closestValidModel(ogl.getModels(MONSTER_IDs), lastFight, 125);
    if (closestMonster.x = 0) then
    begin
      wait(1500);
      exit(false);
    end
    else if (not closestMonster.isVisible()) then
    begin
      currentRadians := minimap.getRadians();
      if (closestMonster.x < (CLIENT_HEIGHT / 2)) then
        minimap.setDegrees(minimap.getDegrees() + random(20, 30))
      else
        minimap.setDegrees(minimap.getDegrees() - random(10, 40));
      adjustment := currentRadians - minimap.getRadians();
      lastFight := rotatePoint(getLastFight, - adjustment, center.x, center.y);
      exit(false);
    end
    else
    begin
      mouse.click(closestMonster.adjustposition(rx, ry).randomizePointEllipse(3), 2);
      wait(75);
      if pos('Attack', mouse.getTooltip()) then
      begin
        mouse.click(mouse.getPoint(), 1);
        wait(100);
        if pos('red', mouse.getClick()) then
        begin
          attackTimer.setTime(randomRange(3000, 4500));
          while (not attackTimer.isFinished) do
          begin
            wait(250);
            lastFight := getLastFight();
            if inCombat() then
              break;
          end;
          progressReport;
          exit(true);
        end
        else
        begin
          wait(randomRange(100, 250));
          exit(false);
        end;
      end
      else if ((tries >= 5)) and (mouse.rightClickOption(mouse.getPoint(), 'Attack', 750)) then
      begin
        attackTimer.setTime(randomRange(3000, 4500));
        while (not attackTimer.isFinished) do
        begin
          wait(250);
          lastFight := getLastFight();
          if inCombat() then
            break;
        end;
        progressReport;
        exit(true);
      end
      else
      begin
        inc(tries);
        rx := rx + (random( - 20, 20));
        ry := ry + (random( - 20, 20));
      end;
    end;
  end;
end;

function canThreshold(ability: string): boolean;
var
  adrenReq: integer;
begin
  case ability of
  'overpower':
      adrenReq := 100;
   'forcefulbackhand':
      adrenReq := 50;
   'flurry':
      adrenReq := 50;
   'hurricane':
      adrenReq := 50;
   'massacre':
      adrenReq := 100;
   'meteorstrike':
      adrenReq := 100;
   'stomp':
      adrenReq := 50;
   'destroy':
      adrenReq := 50;
   'quake':
      adrenReq := 50;
   'berserk':
      adrenReq := 100;
   'assault':
      adrenReq := 50;
   'pulverise':
      adrenReq := 100;
   'frenzy':
      adrenReq := 100;
   'snapshot':
      adrenReq := 50;
   'deadshot':
      adrenReq := 100;
   'tightbindings':
      adrenReq := 50;
   'rapidfire':
      adrenReq := 50;
   'bombardment':
      adrenReq := 50;
   'incendiaryshot':
      adrenReq := 100;
   'asphyxiate':
      adrenReq := 50;
   'omnipower':
      adrenReq := 100;
   'deepimpact':
      adrenReq := 50;
   'detonate':
      adrenReq := 50;
   'wildmagic':
      adrenReq := 50;
   'metamorphosis':
      adrenReq := 100;
   'tsunami':
      adrenReq := 100;
   'revenge':
      adrenReq := 50;
   'immortality':
      adrenReq := 100;
   'reflect':
      adrenReq := 50;
   'rejuvenate':
      adrenReq := 100;
   'debilitate':
      adrenReq := 50;
   'barricade':
      adrenReq := 100;
  end;
  if (actionbar.getAdrenaline() >= adrenReq) then
    if (not actionbar.isAbilityOnCoolDown(ability)) then
      if (not actionbar.isAbilityQueued(ability)) then
        result:=true;
end;

procedure useThresholds;
var
  i: integer;
  threshold: string;
begin
  for i:=0 to high(THRESHOLD_ORDER) do
  begin
    threshold := lowercase(extractFromStr(THRESHOLD_ORDER[i], letters));
    if canThreshold(threshold) then
    begin
      sendkeys(actionbar.getAbilityKey(threshold), random(25, 40), random(80, 110));
      wait(randomRange(750, 1250));
      exit;
    end;
  end;
end;

function regenerateHealth: boolean;
begin
  actionbar.setRegenerate(true);
  wait(randomRange(750, 1250));
  while (actionbar.getAdrenaline() > 0) do
  begin
    wait(randomRange(750, 1250));
    if inCombat() then
      break;
  end;
end;

procedure setMicroBreak;
begin
  microBreakCountdown.setTime((TAKE_MICRO_BREAK_EVERY * 60000) + (randomRange(-300000, 300000)));
end;

procedure takeMicroBreak;
var
  breakTime: tCountDown;
begin
  breakTime.setTime(randomRange(10000, 30000));
  inc(breaksTaken);
  while (not breaktime.isFinished()) do
  begin
    currentStatus:=('Taking break for ' + toStr(round(breakTime.timeRemaining()/1000)) + ' more seconds.');
    progressReport;
    wait(1000);
  end;
  setMicroBreak;
end;

procedure combatLoop;
begin
  repeat
    if getXP() <> currentXP then
    begin
      inc(kills);
      currentXP := getXP();
    end;
    if (terminateTimer.isFinished()) or (actionbar.getLifePoints() < TERMINATE_AT_PERCENT)
      or (TERMINATE_ON_INVENTORY_FULL and inventory.isFull()) or (kills >= TERMINATE_AT_KILL_COUNT) then
      terminateScript;
    if TAKE_MICRO_BREAKS and microBreakCountdown.isFinished() then
      takeMicroBreak;
    if mainScreen.getVerticalDegrees() < random(55, 60) then
    begin
      mainscreen.setVerticalDegrees(random(67, 69));
      wait(250);
    end;
    if (not ogl.getTextures(714000).isEmpty()) then
      clickExitButton;
    if actionbar.setAutoRetaliate(true) then
      wait(randomRange(500, 1000));
    while hasAlchables() do
      alchItems;
    if DRINK_POTIONS then
      checkBuffs;
    if USE_THRESHOLDS then
      useThresholds;
    if (not inCombat()) then
    begin
      if USE_REGENERATE and (actionbar.getLifePoints() < (REGENERATE_AT + randomRange(-5, 5))) then
        regenerateHealth();
      if ((LOOT_BONES) and (hasBones()) and (not inventory.isFull())) then
        lootBones
      else if ((LOOT_ITEMS) and (hasLoot()) and (not inventory.isFull())) then
        lootItems
      else if ((LOOT_CHARMS) and (hasCharms()) and (not inventory.isFull())) then
        lootCharms
      else if (LOOT_BONES and inventory.isFull()) then
        dropBones
      else
        attackMonster;
      currentStatus:='Killing monsters.';
    end;
    lastFight := getLastFight;
    if USE_FOOD and lowHealth() then
      eatFood;
  until(false);
end;

procedure initialSetup;
begin
  center := ogl.getClientMidPoint();
  terminateTimer.setTime((TERMINATE_AFTER * 60000) + (randomRange(-300000, 300000)));
  if TAKE_MICRO_BREAKS then
    setMicroBreak;
  case lowercase(SKILL_TO_TRACK) of
    'attack' : xpIcon:= ogl.getTextures(16918);
    'strength' : xpIcon:= ogl.getTextures(39319);
    'defense' : xpIcon:= ogl.getTextures(41952);
    'ranged' : xpIcon:= ogl.getTextures(20999);
    'mage' : xpIcon:= ogl.getTextures(51211);
    'overall' : xpIcon:= ogl.getTextures(48705);
  end
  if xpIcon.isEmpty() then
  begin
    writeln('XP Tracker Icon not found, enable it in Settings');
    terminateScript;
  end;
  currentXP := getXP();
  startXp := currentXP;
end;

begin
  //getUpdate();
  ogl.setup(CLIENT_WIDTH, CLIENT_HEIGHT);
  ogl.setDebugMode('n');
  initialSetup;

  if GATHER_MONSTER_IDs then
    gatherMonsterIDs
  else if GET_INVENTORY_IDs then
    getInventoryIDs
  else
    combatLoop;
end.
